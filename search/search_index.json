{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Repository for various \u03bcbenchmarks results on my personal hardware:</p>"},{"location":"#cpu","title":"CPU","text":"<ul> <li>Trees and data-structures</li> </ul>"},{"location":"#gpu","title":"GPU","text":""},{"location":"#storage-filesystem","title":"Storage &amp; FileSystem","text":""},{"location":"CPU/","title":"CPU","text":"<ul> <li>Trees and data-structures</li> </ul>"},{"location":"CPU/trees/","title":"Trees and data-structures","text":"<p>Trees are O(ln(n)) and tend to be widely used. But how much time do we loose by using them?</p>"},{"location":"CPU/trees/#hardware-description","title":"Hardware description","text":"<ul> <li>AMD Ryzen 5900x 12-Core @3.7GHz (zen3, up to 4.951GHz)</li> <li>2x 32GB-DDR4-ECC-unbuffered (PN: 9965745-020.A00G)</li> </ul>"},{"location":"CPU/trees/#bench-list","title":"\u03bcBench list","text":""},{"location":"CPU/trees/#arrays-malloc","title":"Arrays (malloc())","text":"<pre><code>typedef uint32_t E;\nE *aTest = (E*)malloc(max * sizeof(E));\n</code></pre>"},{"location":"CPU/trees/#vectors-stdvector","title":"Vectors (std::vector)","text":"<pre><code>typedef uint32_t E;\nstd::vector&lt;E&gt; vecTest;\n</code></pre>"},{"location":"CPU/trees/#red-black-tree-stdmap","title":"Red-Black tree (std::map)","text":"<pre><code>typedef uint32_t E;\nstd::map&lt;E, E&gt; mapTest;\n</code></pre>"},{"location":"CPU/trees/#red-black-tree-optimized","title":"Red-Black tree (optimized)","text":"<ul> <li>Switch from 64b pointers to 32b array indexes</li> <li>No support variable length keys and payload (eg: strings)</li> <li>Room for improvement:<ul> <li>use 31b indexes to save 1 bit for the color (and 1 byte per element)</li> </ul> </li> </ul>"},{"location":"CPU/trees/#b-tree","title":"B-tree","text":"<p>Todo</p> <p>Should reduce the number of memory jumps</p>"},{"location":"CPU/trees/#step-by-step-analysis","title":"Step By Step Analysis","text":""},{"location":"CPU/trees/#timing-comparison","title":"Timing comparison","text":"<p>Observations:</p> <ul> <li>The curves are looking logarithmic</li> <li>The access pattern matters</li> <li>The random accesses are noisy and slower by magnitude orders</li> </ul>"},{"location":"CPU/trees/#cpu-cycles-comparison","title":"CPU cycles comparison","text":"<p>Observations:</p> <ul> <li>Same results (the system is was not loaded)</li> <li>It's easier to see that with Trees, the efficiency is lower than 1%</li> </ul>"},{"location":"CPU/trees/#cpu-cycles-in-loglog-scale","title":"CPU cycles in loglog scale","text":"<p>Observations:</p> <ul> <li>Cache effects are clearly shown</li> <li>Vector/Array random accesses are slower<ul> <li>it's due to the benchmark implementation</li> <li>a better one (and a larger one) should also show cache effects</li> </ul> </li> </ul>"},{"location":"CPU/trees/#hardware-counters","title":"Hardware counters","text":"<p>Observations:</p> <ul> <li>L2 influence from ~2^10 to 2^15</li> <li>The bump from 2^24 to 2^27 might be due to the L3 (I failed to retrieve the L3 misses from this CPU)</li> </ul>"},{"location":"CPU/trees/#summary","title":"Summary","text":"size per element access latency (nsec) access latency (cycle) array 4B 1.392 6.029 vectors 4B 1.362 6.029 rb-tree (std::map) 48B 1099.96 4742.51 rb-tree (custom) 21B 770.55 3791.34 b-tree (abseil) b-tree (custom1) b-tree (custom2) b-tree (custom3)"},{"location":"tags/","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"}]}